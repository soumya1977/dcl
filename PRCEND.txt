$!**********************************************************************
$!     PRCEND.COM (see comments at bottom)                             *
$!                                                                     *
$!     PRE PROCESSING JOB for the PRC 2.2 .                            *
$!**********************************************************************
$!
$INITIALISATION:
$       set on
$       set verify
$       set nocontrol       = y
$!
$       on error then goto RUNERROR	
$!
$       vcs_msg_no := "01"
$       vcs_msg    := "PROGRAM_ABNORMALLY_ENDED,_CALL_PROCUREMENT_SUPPORT"
$       vcs_msg1   := "EVENING CYCLE IS STILL RUNNING,_CALL_PROCUREMENT_SUPPORT"
$       vcs_msg2   := "MONTH_END:DFB020 LOG MISSING  ,_CALL_PROCUREMENT_SUPPORT"
$       vcs_msg3   := "INTENTIONAL JOB ABORT AS NOT REQUIRED AT MONTHEND"
$       vcs_msg4   := "MONTH_END:DFB020 LOG OLD VER  ,_CALL_PROCUREMENT_SUPPORT"
$	vcs_start  := "00-PROCESS_STARTED"
$	vcs_ok	   := "00-PROCESS_SUCCESSFULLY_ENDED"
$	job_name   := "PRCEND"
$       account_name        = f$getjpi("","account")
$!
$       delete     := delete
$       purge      := purge
$       define     := define
$       write      := write
$       run        := run
$!
$!
$!**********************************************************************
$!     CHECK IF SATURDAY OF MONTHEND: IF YES DO USER ABORT             *
$!                                    AS NO SYSTEM REQUIRED            *
$!**********************************************************************
$!
$SAT_MONTHEND_CHECK:
$       TIME_STAMP = F$TIME()
$!
$       WEEKDAY    = F$CVTIME(TIME_STAMP,,"WEEKDAY")
$       YESTERDAY  = F$CVTIME("YESTERDAY","absolute","date")
$       TODAY      = F$CVTIME("TODAY","absolute","date")
$!
$!---Only if it is a saturday, we need to check if is monthend
$!
$	if  weekday .eqs. "Saturday"
$       then
$!---Strings generated by days below 10 are shorter, pad it
$!
$           if f$extract(02, 01, yesterday ) .nes. "-"
$           then
$              yesterday = " " + yesterday
$           endif
$!
$           if f$extract(02, 01, today ) .nes. "-"
$           then
$              today     = " " + today
$           endif
$!
$           filename  = "PRCERRLOG:DFB020.log"
$           filedate1 = f$file_attributes( "''filename'", "CDT" )
$           filedate  = f$extract( 00, 11, filedate1 )
$!
$           if f$search("''filename'") .eqs. "" 
$           then
$!---If the log file doesn't exist then it is a real mistake
$!
$         	request "%''account_name'_''job_name'_''vcs_msg2'"
$               error_status = 2
$               goto exit
$           else
$               write sys$output "File: #''filedate'# Yesterday: #''yesterday'# Today: #''today'#"
$!
$!---Check if the file was generated during the last 2 days (saturday and friday)
$!
$               if  (filedate .eqs. yesterday) .OR. (filedate .eqs. today)    
$               then
$!---This case is the normal way like it should always work !
$!
$      	            continue
$               else
$!---If the file is not from the 2 previous days then it is also a problem
$!
$           	    request "%''account_name'_''job_name'_''vcs_msg4'"
$                   error_status = 2
$                   goto exit
$               endif
$           endif
$!
$!---Investigate the contents of the file to determine if we are at
$!---monthend or weekend
$!
$           open/read input 'filename'
$           month_flag = "Y"
$!
$RECORD_LOOP:     
$           read/end_of_file=check_for_monthend_exit input record_r1
$!
$           if f$extract( 17, 23, record_r1 ) .eqs. "Message number 00000006"
$           then
$               month_flag = "N" 
$               goto check_for_monthend_exit
$           else
$               goto record_loop
$           endif
$!
$CHECK_FOR_MONTHEND_EXIT:
$	    close input
$!
$           if month_flag .eqs. "Y"
$           then
$               write sys$output "----------------------------------------------"
$               write sys$output "   SCHEDULE ABORTED TODAY AS IT IS MONTHEND   "
$               write sys$output "----------------------------------------------"
$               write sys$output " "
$!
$	        request "%''account_name'_''job_name'_''vcs_msg3'"
$               error_status = "%X00000006"
$               goto exitnew
$           endif
$       else
$           write sys$output ">>> Today was a : ''weekday'"
$       endif
$!
$!**********************************************************************
$!     START CHECKS TO SEE IF CAN BRING UP MENU SYSTEM IN UPDATE MODE  *
$!**********************************************************************
$!
$START:
$ set nover
$!
$       system_start       := "Y"
$	request "%''account_name'_''job_name'_''vcs_start'"
$       @oppsmg_system:psmgdcmwrite -
	        'job_name' - 
        	"Starting PRC 2.2 System." 
$!
$!
$!**********************************************************************
$! This part will loop through the system getting all the PROCESS      *
$! who belong in OUR Group and IF they are anything other than         *
$! the SCHEDULAR process OPPSMGCONTROL then we cannot start the system.*  
$! Of course check and allow our own process ie PRCEND or XMIT jobs.   *
$! Save and reset our privs , we only need group privs.                *    
$!**********************************************************************
$!
$CHECK_MODE:
$	ori_priv = f$setprv("NOALL")
$       set proc/priv=(OPER,TMPMBX,NETMBX,GROUP)
$!
$	schedular_processes_active := "NO"
$	context = ""
$       batch_running = "non"
$       test_loop = 1
$!
$	write sys$output "The following Processes are Active in the System.  "
$	write sys$output "---------------------------------------------------"
$       write sys$output " "
$get_loop:
$	pid = f$pid(context)
$	if pid .eqs. "" 
$          then 
$              if batch_running .eqs. "yes"
$                 then 
$                     batch_running = "non"
$                     context = ""
$                     Wait 00:10:00
$                     write sys$output "---------------------------------------------------"
$                     goto end_get_loop
$                 else
$                     context = ""
$                     goto end_get_loop
$              endif
$       endif
$!
$	username = f$edit(f$getjpi(pid,"USERNAME"),"UPCASE,COLLAPSE")
$	i_name = f$getjpi(pid,"IMAGNAME")
$	p_name = f$edit(f$getjpi(pid,"PRCNAM"),"UPCASE,COLLAPSE")
$	p_mode = f$edit(f$getjpi(pid,"MODE"),"UPCASE,COLLAPSE")
$!
$       if p_mode .eqs. "INTERACTIVE" then goto get_loop
$!
$!******************  IF SMG JOBS RUNNING CONTINUE  *****************
$	if p_name .eqs. "OPPSMGCONTROL" then goto get_loop
$	if p_name .eqs. "PSMG3510" then goto get_loop
$!
$!*********** IF JOBS RUNNING OTHER THAN DRP/PROC CONTINUE **********
$ 	if username .nes. "PRPSCH" then goto get_loop
$
$!******* IF DRP/PROC STARTUP JOBS RUNNING CONTINUE *****************
$	if p_name .eqs. "PRPEND1" then goto get_loop
$	if p_name .eqs. "PRPEND2" then goto get_loop
$	if p_name .eqs. "PRPEND3" then goto get_loop
$	if p_name .eqs. "PRPEND4" then goto get_loop
$	if p_name .eqs. "PRPEND5" then goto get_loop
$	if p_name .eqs. "PRPEND6" then goto get_loop
$ set ver
$!
$!******* IF DRP/PROC XMIT JOBS STILL RUNNING CONTINUE **************
$	if p_name .eqs. "TESTSNA"     then goto get_loop
$!
$	if p_name .eqs. "D_0_PIB0001" then goto get_loop
$!
$	if p_name .eqs. "D_0_PIB0050" then goto get_loop
$	if p_name .eqs. "D_0_PIB0051" then goto get_loop
$!
$	if p_name .eqs. "E_0_PDIB010" then goto get_loop
$	if p_name .eqs. "E_0_PDIB012" then goto get_loop
$	if p_name .eqs. "E_0_PDIB013" then goto get_loop
$	if p_name .eqs. "E_0_PDIB014" then goto get_loop
$	if p_name .eqs. "E_0_PIB0009" then goto get_loop
$	if p_name .eqs. "E_0_PIB0015" then goto get_loop
$	if p_name .eqs. "E_0_PIB0025" then goto get_loop
$	if p_name .eqs. "E_0_PIB0041" then goto get_loop
$	if p_name .eqs. "E_0_PIB0042" then goto get_loop
$	if p_name .eqs. "E_0_PIB0043" then goto get_loop
$	if p_name .eqs. "E_0_PIB0050" then goto get_loop
$	if p_name .eqs. "E_0_PIB0051" then goto get_loop
$	if p_name .eqs. "E_0_PIB0052" then goto get_loop
$	if p_name .eqs. "E_0_PIB0053" then goto get_loop
$!                                  
$       test_hour = f$time()
$       test_hour = f$extract (12,2,test_hour) + f$extract (15,2,test_hour)
$       write sys$output "''test_hour' ''Username' ''PID' ''P_name' ''P_Mode'"
$!
$       if p_mode .eqs. "OTHER"
$          then
$              batch_Running = "yes"
$              test_loop = 1
$!
$              if weekday .eqs. "Friday"
$                 then 
$                     if test_hour .gt. "0750"
$                        then 
$                            goto Call_Out
$                     endif
$                 else 
$                     if test_hour .gt. "0515"
$                        then 
$                            goto Call_Out
$                     endif
$              endif
$	endif
$!
$ set nover
$	goto get_loop
$!
$End_get_loop:
$!
$ if test_loop .lt. 3
$    then 
$        Wait 00:01:00
$        test_loop = test_loop + 1
$        goto get_loop
$    else
$        goto update_msg
$ endif
$!
$!
$!**********************************************************************
$!     SPECIAL CALL_OUT MESSAGE WHEN JOBS RUNNING AFTER TIME LIMIT     *
$!**********************************************************************
$!
$Call_Out:
$!
$       schedular_processes_active := "YES"
$       write sys$output "''Username' ''PID' ''P_name' ''P_Mode'"
$       @oppsmg_system:psmgdcmwrite 'job_name' - 
        	"Batch cycle still active, CALL PROCUREMENT SUPPORT"
$!
$       goto update_msg
$!
$!
$!*****************************************************************************
$!                                                                            *
$! If processes are still active in the system after the deadline time        *
$! for the day of the week then display in the log message to say system      *
$! is being brought up in inquiry mode only: THE JOB WILL ABORT and needs     *
$! a retry to ensure system is placed in update mode and backups are done.    *
$!                                                                            *
$!*****************************************************************************
$!
$UPDATE_MSG:
$    set proc/priv=('ori_priv')
$    if schedular_processes_active .eqs. "YES" 
$    then 
$       write sys$output "          SYSTEM NOT IN UPDATE MODE             "
$       write sys$output "         ============================           " 
$       write sys$output " "
$       write sys$output "If we are NOT in a MONTHEND, then it is possible  "
$       write sys$output "that we have OVER-RUN the overnight schedule times"
$       write sys$output "due to problems with the Overnight Processing and "
$       write sys$output "therefore the system should not be brought up in "
$       write sys$output "in update mode. The support person should ensure"
$       write sys$output "that all jobs are completed before retrying job. "   
$       write sys$output "In any eventuality the Operator should be aware, "
$       write sys$output "that : - "
$       write sys$output " "
$       write sys$output "1. The MENUS have been put back ONLINE."
$       write sys$output "2. The PROCUREMENT system is in INQUIRERY Mode."
$       write sys$output "3. The DEPBATCH queue has NOT been started."
$       write sys$output "4. The morning back-ups have not been done."
$	write sys$output " "
$       system_start       := "N"
$    endif
$!
$!
$!****************************************************************************
$! This part places the specified menus ONLINE, if it errors it is           *
$! critical , TAKE NORMAL ERROR PROCESSING.                                  *
$!                                                                           *
$! save and reset privs (not sure what we should have so set all).           *
$! NOTE : We must re-assign the logical TT to point to NL: before we run the  *
$!        program PSMG0006 , the reason is that Mr Rodgers in his wisdom      *
$!        decided to use the system service function , "SMG$CREATE_PASTEBOARD"* 
$!        specifying logical TT. (TT is the logical for SYS$COMMAND) in       *
$!        this case as we are running DETACHED it is "THIS COMMAND FILE". This*
$!        has the effect of "creating a new COMMAND FILE" containing the      *
$!        output from "PSMG0006" , so the next time we run we get garbage as  *
$!        our command file.                                                   *
$!*****************************************************************************
$!
$MENUS_ONLINE:
$	ori_priv = f$setprv("NOALL")
$	set proc/priv=all
$!
$       write sys$output "-----------------------------------------------------
$       write sys$output "      Placing the Specified PRC menus ONLINE."
$       write sys$output " "
$       write sys$output "      Menu to Put ONLINE: DC01."
$       write sys$output " "
$       write sys$output "-----------------------------------------------------
$	define/nolog/proc psmgmenu  oppsmg_system:menu.dat
$	define/user tt nl:
$	run oppsmg_system:psmg0006.exe
DC01
EXIT
$!
$! Reset privs back.
$!
$	set proc/priv=('ori_priv')
$!
$!
$!*****************************************************************************
$!                                                                            *
$! Purpose:            This procedure restores the original                   *
$!                     transaction authorisation file to change the           *
$!                     NOVUS system to an updateable status, if no            *
$!                     processes are running after the morning backups have   *
$!                     been completed by the operators.                       *
$!		       Also start the DEPBATCH queue.                         *
$!                                                                            *
$!*****************************************************************************
$!
$       set noon
$       if system_start .eqs. "Y"
$       then
$           @oppsmg_system:psmgdcmwrite - 
            'job_name' - 
            "Reply when PRC 2.2 B/UPS Have Completed for sta1 and sta2." -
            "REPLY"
$!
$           @oppsmg_system:psmgdcmremove 'job_name'
$!
$           write sys$output "-----------------------------------------------------
$           write sys$output "   RESTORE ORIGINAL COPY OF THE TRANSACTION"
$           write sys$output "   AUTHORIZATION FILE, SO THAT ALL NOVUS SCREENS"
$           write sys$output "   ARE SET BACK TO AN UPDATEABLE STATUS."
$           write sys$output " "
$           rename/log data:ta.bck data:ta.dat
$	    purge/log data:ta.dat
$           write sys$output "-----------------------------------------------------
$	    q_stopped = f$getqui("display_queue","queue_stopped","depbatch")
$           if q_stopped then start/queue depbatch
$!          now delete everything support has moved during stand_by
$	    set on
$       else
$           write sys$output "----------------------------------------------"
$           write sys$output "   SYSTEM IS IN INQUIRY MODE                  "
$           write sys$output "----------------------------------------------"
$           write sys$output " "
$	    request "%''account_name'_''job_name'_''vcs_msg1'"
$           error_status = 2
$           goto exit
$      endif
$!
$!
$!****************************************************************************
$! When the job has run successfuly and no processes are running             *
$! do last activities.                                                       *
$!****************************************************************************
$!
$CLEAN_UP:
$!
$!***** CREATE FILE FOR CSF ROUTINE 
$!
$       submit/nolog prccom:rmt_check.com;
$!
$!***** Clearing of the SNA_REPORTS 
$!
$	Delete/before=Yesterday SNA_REPORTS:*.*.*
$!
$!***** Purge of USERS areas
$!
$	Purge/log        prpdisk3:[users...]IC.DAT
$!
$!***** Clearing of DRP_BACKUP
$!
$       TIME_STAMP = F$TIME()
$       WEEKDAY    = F$CVTIME(TIME_STAMP,,"WEEKDAY")
$!
$	if  weekday .eqs. "Monday"
$           Then
$                if f$search ("DRP_BACKUP:%%.DIB001.*") .nes. ""
$                   Then
$                        Delete/log DRP_BACKUP:%%.DIB001.*
$                endif
$       endif
$!
$	if  weekday .eqs. "Tuesday"
$           Then
$                if f$search ("DRP_BACKUP:%%.DPB308.*") .nes. ""
$                   Then
$                        Delete/log DRP_BACKUP:%%.DPB308.*
$                endif
$       endif
$!
$!
$	request "%''account_name'_''job_name'_''vcs_ok'"
$       error_status = 1
$!
$!
$!****************************************************************************
$! When the job has run successfuly or unsuccesfuly this exit is taken.      *
$!****************************************************************************
$!
$EXIT:
$!!!!!! Execution to gather the error logs for Proc.
$ set verify
$        @prcbatch:proc_gather_logs.com
$!
$ EXITNEW:
$        sh proc/Account
$        exit error_status
$!
$!
$!****************************************************************************
$! When the job has an error                                                 *
$!****************************************************************************
$!
$RUNERROR:
$!
$       error_status       := '$status
$       set noon
$       request "%''account_name'_''prog_name'_''vcs_msg_no'_''vcs_msg'"
$       goto EXIT
$!
$!
$!****************************************************************************
$!                                                                           *
$!****************************************************************************
$!
$!***********************************************************************
$! Command File and Utility Name: PRCEND.COM
$!
$! Purpose:            To Check to make sure that the SCHEDULAR Detached
$!                     processes are competed.
$!		       Starts the menus, and re-enables access to PRC
$!                     files.
$!
